<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, HTTPException&#10;from fastapi.middleware.cors import CORSMiddleware&#10;import os&#10;from dotenv import load_dotenv&#10;from app.managers.cita_manager import CitaManager&#10;from app.managers.historial_cita import HistorialCita&#10;from app.managers.resultados import Resultados&#10;from app.managers.alertas import Alertas&#10;from app.routers.citas_router import router as citas_router&#10;from app.routers.paciente_router import router as paciente_router&#10;from app.routers.medico_router import router as medico_router&#10;from app.routers.admin_router import router as admin_router&#10;from app.routers.examenes_router import router as examenes_router&#10;&#10;app = FastAPI(title=&quot;VitalApp API&quot;)&#10;&#10;# Cargar .env automáticamente usando python-dotenv si existe&#10;load_dotenv()  # Carga variables desde .env si está presente&#10;&#10;# Configurar CORS&#10;front_desplegado_env = os.getenv(&quot;frontDesplegado&quot;, os.getenv(&quot;FRONT_DESPLEGADO&quot;))&#10;front_default = &quot;*&quot;&#10;allow_origins_list = [origin for origin in [front_desplegado_env, front_default] if origin]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=allow_origins_list,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Leyenda CORS: Se toma la variable frontDesplegado si existe y se añade '*' para pruebas locales.&#10;&#10;# Registrar los routers&#10;app.include_router(citas_router)&#10;app.include_router(paciente_router)&#10;app.include_router(medico_router)&#10;app.include_router(admin_router)&#10;app.include_router(examenes_router)&#10;&#10;# Crear instancias&#10;cm = CitaManager()&#10;hc = HistorialCita()&#10;rs = Resultados()&#10;al = Alertas()&#10;&#10;@app.get(&quot;/&quot;)&#10;def read_root():&#10;    return {&quot;status&quot;: &quot;active&quot;, &quot;message&quot;: &quot;VitalApp API is running&quot;}&#10;&#10;# Leyenda arquitectura:&#10;# main.py -&gt; registra routers (capa de entrada HTTP)&#10;# routers -&gt; validación ligera + dependencias de seguridad JWT&#10;# services -&gt; lógica de negocio (workflow, reglas)&#10;# managers -&gt; fachada legacy/persistencia directa JSON (en transición a repositorios)&#10;# repositories -&gt; abstracción de almacenamiento (JSON ahora, adaptable a SQL)&#10;&#10;# @app.get(&quot;/diagnosticos/{paciente}/{fecha}&quot;)&#10;# def obtener_diagnostico(paciente: str, fecha: str):&#10;#     try:&#10;#         diagnostico = hc.obtener_diagnostico(paciente, fecha)&#10;#         return {&quot;diagnostico&quot;: diagnostico}&#10;#     except Exception as e:&#10;#         raise HTTPException(status_code=404, detail=&quot;Diagnóstico no encontrado&quot;)&#10;#&#10;# @app.get(&quot;/alertas/{paciente}&quot;)&#10;# def obtener_alertas(paciente: str):&#10;#     try:&#10;#         res = rs.obtener_resultados(paciente)&#10;#         alertas = al.generar_alertas(res)&#10;#         return {&quot;alertas&quot;: alertas}&#10;#     except Exception as e:&#10;#         raise HTTPException(status_code=404, detail=&quot;No se encontraron alertas&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=10000)" />
              <option name="updatedContent" value="from fastapi import FastAPI, HTTPException&#10;from fastapi.middleware.cors import CORSMiddleware&#10;import os&#10;from dotenv import load_dotenv&#10;from app.managers.cita_manager import CitaManager&#10;from app.managers.historial_cita import HistorialCita&#10;from app.managers.resultados import Resultados&#10;from app.managers.alertas import Alertas&#10;from app.routers.citas_router import router as citas_router&#10;from app.routers.paciente_router import router as paciente_router&#10;from app.routers.medico_router import router as medico_router&#10;from app.routers.admin_router import router as admin_router&#10;from app.routers.examenes_router import router as examenes_router&#10;&#10;app = FastAPI(title=&quot;VitalApp API&quot;)&#10;&#10;# Cargar .env automáticamente usando python-dotenv si existe&#10;load_dotenv()  # Carga variables desde .env si está presente&#10;&#10;# Configurar CORS&#10;front_desplegado_env = os.getenv(&quot;frontDesplegado&quot;, os.getenv(&quot;FRONT_DESPLEGADO&quot;))&#10;front_default = &quot;*&quot;&#10;allow_origins_list = [origin for origin in [front_desplegado_env, front_default] if origin]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=allow_origins_list,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Leyenda CORS: Se toma la variable frontDesplegado si existe y se añade '*' para pruebas locales.&#10;&#10;# Registrar los routers&#10;app.include_router(citas_router)&#10;app.include_router(paciente_router)&#10;app.include_router(medico_router)&#10;app.include_router(admin_router)&#10;app.include_router(examenes_router)&#10;&#10;# Crear instancias&#10;cm = CitaManager()&#10;hc = HistorialCita()&#10;rs = Resultados()&#10;al = Alertas()&#10;&#10;@app.get(&quot;/&quot;)&#10;def read_root():&#10;    return {&quot;status&quot;: &quot;active&quot;, &quot;message&quot;: &quot;VitalApp API is running&quot;}&#10;&#10;# Leyenda arquitectura:&#10;# main.py -&gt; registra routers (capa de entrada HTTP)&#10;# routers -&gt; validación ligera + dependencias de seguridad JWT&#10;# services -&gt; lógica de negocio (workflow, reglas)&#10;# managers -&gt; fachada legacy/persistencia directa JSON (en transición a repositorios)&#10;# repositories -&gt; abstracción de almacenamiento (JSON ahora, adaptable a SQL)&#10;&#10;# @app.get(&quot;/diagnosticos/{paciente}/{fecha}&quot;)&#10;# def obtener_diagnostico(paciente: str, fecha: str):&#10;#     try:&#10;#         diagnostico = hc.obtener_diagnostico(paciente, fecha)&#10;#         return {&quot;diagnostico&quot;: diagnostico}&#10;#     except Exception as e:&#10;#         raise HTTPException(status_code=404, detail=&quot;Diagnóstico no encontrado&quot;)&#10;#&#10;# @app.get(&quot;/alertas/{paciente}&quot;)&#10;# def obtener_alertas(paciente: str):&#10;#     try:&#10;#         res = rs.obtener_resultados(paciente)&#10;#         alertas = al.generar_alertas(res)&#10;#         return {&quot;alertas&quot;: alertas}&#10;#     except Exception as e:&#10;#         raise HTTPException(status_code=404, detail=&quot;No se encontraron alertas&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=10000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/managers/paciente_manager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/managers/paciente_manager.py" />
              <option name="originalContent" value="import json&#10;import hashlib&#10;import os&#10;from datetime import datetime&#10;from app.config import obtener_archivo_paciente&#10;&#10;&#10;&#10;&#10;&#10;class PacienteManager:&#10;    def __init__(self, base_dir=None):&#10;        &quot;&quot;&quot;&#10;        Gestiona el registro y autenticación de pacientes.&#10;        base_dir permite aislar el almacenamiento (útil en tests).&#10;        &quot;&quot;&quot;&#10;        from app.config import BASE_DATA_DIR&#10;        self.base_dir = base_dir or BASE_DATA_DIR&#10;&#10;&#10;    def _hash_contraseña(self, contraseña: str) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Genera un hash de la contraseña para almacenarla de forma segura.&#10;        &quot;&quot;&quot;&#10;        return hashlib.sha256(contraseña.encode()).hexdigest()&#10;&#10;    def _guardar_paciente(self, datos_paciente: dict):&#10;        &quot;&quot;&quot;&#10;        Guarda los datos del paciente en un archivo JSON.&#10;        &quot;&quot;&quot;&#10;        archivo = obtener_archivo_paciente(datos_paciente[&quot;documento&quot;])&#10;        # No almacenamos la contraseña en texto plano&#10;        datos_a_guardar = datos_paciente.copy()&#10;        datos_a_guardar[&quot;contraseña&quot;] = self._hash_contraseña(datos_paciente[&quot;contraseña&quot;])&#10;        datos_a_guardar[&quot;fecha_registro&quot;] = datetime.now().isoformat()&#10;        &#10;        with open(archivo, &quot;w&quot;) as f:&#10;            json.dump(datos_a_guardar, f, indent=4)&#10;&#10;    def _cargar_paciente(self, documento: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Carga los datos de un paciente desde su archivo JSON.&#10;        &quot;&quot;&quot;&#10;        archivo = obtener_archivo_paciente(documento)&#10;        if not os.path.exists(archivo):&#10;            return None&#10;&#10;        with open(archivo, &quot;r&quot;) as f:&#10;            return json.load(f)&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str, &#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        # Verificar si el paciente ya existe&#10;        if self._cargar_paciente(documento):&#10;            raise ValueError(&quot;Ya existe un paciente con ese documento&quot;)&#10;&#10;        # Crear diccionario con los datos del paciente&#10;        datos_paciente = {&#10;            &quot;documento&quot;: documento,&#10;            &quot;nombre_completo&quot;: nombre_completo,&#10;            &quot;contraseña&quot;: contraseña,&#10;            &quot;telefono&quot;: telefono,&#10;            &quot;email&quot;: email,&#10;            &quot;edad&quot;: self.verificar_edad(edad),&#10;            &quot;sexo&quot;: sexo&#10;        }&#10;&#10;        # Guardar paciente&#10;        self._guardar_paciente(datos_paciente)&#10;        return True&#10;&#10;    def verificar_edad(self, edad):&#10;        # verificamos que sea mayor de 18 años&#10;        try:&#10;            edad_int = int(edad)&#10;        except (TypeError, ValueError):&#10;            raise ValueError(&quot;Edad inválida&quot;)&#10;        if edad_int &lt; 18:&#10;            raise ValueError(&quot;Debe ser mayor de edad para registrarse&quot;)&#10;        return edad_int&#10;&#10;    def autenticar_paciente(self, documento: str, contraseña: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente verificando su documento y contraseña.&#10;        &quot;&quot;&quot;&#10;        paciente = self._cargar_paciente(documento)&#10;        if not paciente:&#10;            return False&#10;&#10;        hash_contraseña = self._hash_contraseña(contraseña)&#10;        return paciente.get(&quot;contraseña&quot;) == hash_contraseña&#10;&#10;    def obtener_datos_paciente(self, documento: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene los datos de un paciente sin la contraseña.&#10;        &quot;&quot;&quot;&#10;        paciente = self._cargar_paciente(documento)&#10;        if paciente:&#10;            # Remover la contraseña antes de devolver los datos&#10;            paciente.pop(&quot;contraseña&quot;, None)&#10;            return paciente&#10;        return None&#10;&#10;    def existe_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return os.path.exists(obtener_archivo_paciente(documento))" />
              <option name="updatedContent" value="import json&#10;import hashlib&#10;import os&#10;from datetime import datetime&#10;from app.config import obtener_archivo_paciente&#10;&#10;&#10;&#10;&#10;&#10;class PacienteManager:&#10;    def __init__(self, base_dir=None):&#10;        &quot;&quot;&quot;&#10;        Gestiona el registro y autenticación de pacientes.&#10;        base_dir permite aislar el almacenamiento (útil en tests).&#10;        &quot;&quot;&quot;&#10;        from app.config import BASE_DATA_DIR&#10;        self.base_dir = base_dir or BASE_DATA_DIR&#10;&#10;&#10;    def _hash_contraseña(self, contraseña: str) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Genera un hash de la contraseña para almacenarla de forma segura.&#10;        &quot;&quot;&quot;&#10;        return hashlib.sha256(contraseña.encode()).hexdigest()&#10;&#10;    def _guardar_paciente(self, datos_paciente: dict):&#10;        &quot;&quot;&quot;&#10;        Guarda los datos del paciente en un archivo JSON.&#10;        &quot;&quot;&quot;&#10;        archivo = obtener_archivo_paciente(datos_paciente[&quot;documento&quot;])&#10;        # No almacenamos la contraseña en texto plano&#10;        datos_a_guardar = datos_paciente.copy()&#10;        datos_a_guardar[&quot;contraseña&quot;] = self._hash_contraseña(datos_paciente[&quot;contraseña&quot;])&#10;        datos_a_guardar[&quot;fecha_registro&quot;] = datetime.now().isoformat()&#10;        &#10;        with open(archivo, &quot;w&quot;) as f:&#10;            json.dump(datos_a_guardar, f, indent=4)&#10;&#10;    def _cargar_paciente(self, documento: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Carga los datos de un paciente desde su archivo JSON.&#10;        &quot;&quot;&quot;&#10;        archivo = obtener_archivo_paciente(documento)&#10;        if not os.path.exists(archivo):&#10;            return None&#10;&#10;        with open(archivo, &quot;r&quot;) as f:&#10;            return json.load(f)&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str, &#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        # Verificar si el paciente ya existe&#10;        if self._cargar_paciente(documento):&#10;            raise ValueError(&quot;Ya existe un paciente con ese documento&quot;)&#10;&#10;        # Crear diccionario con los datos del paciente&#10;        datos_paciente = {&#10;            &quot;documento&quot;: documento,&#10;            &quot;nombre_completo&quot;: nombre_completo,&#10;            &quot;contraseña&quot;: contraseña,&#10;            &quot;telefono&quot;: telefono,&#10;            &quot;email&quot;: email,&#10;            &quot;edad&quot;: self.verificar_edad(edad),&#10;            &quot;sexo&quot;: sexo&#10;        }&#10;&#10;        # Guardar paciente&#10;        self._guardar_paciente(datos_paciente)&#10;        return True&#10;&#10;    def verificar_edad(self, edad):&#10;        # verificamos que sea mayor de 18 años&#10;        try:&#10;            edad_int = int(edad)&#10;        except (TypeError, ValueError):&#10;            raise ValueError(&quot;Edad inválida&quot;)&#10;        if edad_int &lt; 18:&#10;            raise ValueError(&quot;Debe ser mayor de edad para registrarse&quot;)&#10;        return edad_int&#10;&#10;    def autenticar_paciente(self, documento: str, contraseña: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente verificando su documento y contraseña.&#10;        &quot;&quot;&quot;&#10;        paciente = self._cargar_paciente(documento)&#10;        if not paciente:&#10;            return False&#10;&#10;        hash_contraseña = self._hash_contraseña(contraseña)&#10;        return paciente.get(&quot;contraseña&quot;) == hash_contraseña&#10;&#10;    def obtener_datos_paciente(self, documento: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene los datos de un paciente sin la contraseña.&#10;        &quot;&quot;&quot;&#10;        paciente = self._cargar_paciente(documento)&#10;        if paciente:&#10;            # Remover la contraseña antes de devolver los datos&#10;            paciente.pop(&quot;contraseña&quot;, None)&#10;            return paciente&#10;        return None&#10;&#10;    def existe_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return os.path.exists(obtener_archivo_paciente(documento))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/paciente_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/paciente_service.py" />
              <option name="originalContent" value="from app.managers.paciente_manager import PacienteManager&#10;from app.config import crear_token_acceso&#10;from app.managers.admin_manager import AdminManager&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;&#10;&#10;class PacienteService:&#10;    # Leyenda: Servicio de pacientes.&#10;    # Responsabilidades: registro, login, lectura de exámenes (legacy), verificación existencia.&#10;    # Próxima migración: usar repositorios para separar persistencia; unificar acceso a exámenes vía workflow.&#10;    def __init__(self, base_dir=None):&#10;        if base_dir is not None:&#10;            from app.config import BASE_DATA_DIR as GLOBAL_BASE&#10;            # Reasignar BASE_DATA_DIR dinámicamente para este servicio no es trivial; usamos base_dir explícito.&#10;            self.paciente_manager = PacienteManager(base_dir=base_dir)&#10;            self.admin_manager = AdminManager(base_dir=base_dir)&#10;            self.examen_workflow = ExamenWorkflowService()&#10;            # Override repos del workflow al mismo base_dir&#10;            self.examen_workflow.solicitud_repo.base_dir = base_dir&#10;            self.examen_workflow.resultado_repo.base_dir = base_dir&#10;        else:&#10;            self.paciente_manager = PacienteManager()&#10;            self.admin_manager = AdminManager()&#10;            self.examen_workflow = ExamenWorkflowService()  # Acceso a resultados workflow&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str,&#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            return self.paciente_manager.registrar_paciente(&#10;                documento, nombre_completo, contraseña, telefono, email, edad, sexo&#10;            )&#10;        except ValueError as e:&#10;            raise e&#10;        except Exception as e:&#10;            raise Exception(f&quot;Error al registrar paciente: {str(e)}&quot;)&#10;&#10;    def login_paciente(self, documento: str, contraseña: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente y genera un token de acceso.&#10;        &quot;&quot;&quot;&#10;        if self.paciente_manager.autenticar_paciente(documento, contraseña):&#10;            # Obtener datos del paciente sin la contraseña&#10;            datos_paciente = self.paciente_manager.obtener_datos_paciente(documento)&#10;            if datos_paciente:&#10;                # Crear token de acceso con los datos del paciente&#10;                token = crear_token_acceso({&#10;                    &quot;documento&quot;: documento,&#10;                    &quot;nombre_completo&quot;: datos_paciente[&quot;nombre_completo&quot;],&#10;                    &quot;tipo_usuario&quot;: &quot;paciente&quot;&#10;                })&#10;                &#10;                return {&#10;                    &quot;token&quot;: token,&#10;                    &quot;paciente&quot;: datos_paciente&#10;                }&#10;        &#10;        raise ValueError(&quot;Credenciales inválidas&quot;)&#10;&#10;    def verificar_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return self.paciente_manager.existe_paciente(documento)&#10;&#10;    def obtener_examenes_paciente(self, documento: str) -&gt; list:&#10;        &quot;&quot;&quot;&#10;        Obtiene todos los exámenes de un paciente.&#10;        &quot;&quot;&quot;&#10;        #legacy = self.admin_manager.listar_examenes_paciente(documento)&#10;        workflow = self.examen_workflow.listar_resultados_paciente(documento)&#10;        normalizados = []&#10;        # for ex in legacy:&#10;        #     normalizados.append({&#10;        #         &quot;codigo&quot;: ex.get(&quot;codigo_examen&quot;),&#10;        #         &quot;tipo_examen&quot;: ex.get(&quot;examen_solicitado&quot;),&#10;        #         &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;        #         &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;        #         &quot;documento_medico&quot;: (ex.get(&quot;medico&quot;) or {}).get(&quot;documento&quot;),&#10;        #         &quot;diagnostico&quot;: ex.get(&quot;diagnostico&quot;),&#10;        #         &quot;interpretacion&quot;: ex.get(&quot;diagnostico&quot;),  # legacy no distingue&#10;        #         &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;        #         &quot;estado&quot;: ex.get(&quot;estado&quot;),&#10;        #         &quot;estado_riesgo&quot;: None,&#10;        #         &quot;origen&quot;: &quot;legacy&quot;,&#10;        #         &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;        #     })&#10;        for ex in workflow:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;id&quot;),&#10;                &quot;tipo_examen&quot;: None,  # solicitud inicial guarda tipo en solicitud, no en resultado&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: ex.get(&quot;documento_medico&quot;),&#10;                &quot;diagnostico&quot;: None,&#10;                &quot;interpretacion&quot;: ex.get(&quot;interpretacion&quot;),&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: &quot;resultado&quot;,  # resultado consolidado&#10;                &quot;estado_riesgo&quot;: ex.get(&quot;estado_riesgo&quot;),&#10;                &quot;origen&quot;: &quot;workflow&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        return normalizados&#10;&#10;    def obtener_resultado_examen(self, codigo_examen: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene el resultado de un examen específico.&#10;        &quot;&quot;&quot;&#10;        # Intentar legacy&#10;        ex_legacy = self.admin_manager.obtener_resultado_examen(codigo_examen)&#10;        if ex_legacy:&#10;            return ex_legacy&#10;        # Buscar en resultados workflow (lista completa)&#10;        for r in self.examen_workflow.resultado_repo.list():&#10;            if r.get(&quot;id&quot;) == codigo_examen or r.get(&quot;solicitud_id&quot;) == codigo_examen:&#10;                return r&#10;        return None&#10;" />
              <option name="updatedContent" value="from app.managers.paciente_manager import PacienteManager&#10;from app.config import crear_token_acceso&#10;from app.managers.admin_manager import AdminManager&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;&#10;&#10;class PacienteService:&#10;    # Leyenda: Servicio de pacientes.&#10;    # Responsabilidades: registro, login, lectura de exámenes (legacy), verificación existencia.&#10;    # Próxima migración: usar repositorios para separar persistencia; unificar acceso a exámenes vía workflow.&#10;    def __init__(self, base_dir=None):&#10;        if base_dir is not None:&#10;            from app.config import BASE_DATA_DIR as GLOBAL_BASE&#10;            # Reasignar BASE_DATA_DIR dinámicamente para este servicio no es trivial; usamos base_dir explícito.&#10;            self.paciente_manager = PacienteManager(base_dir=base_dir)&#10;            self.admin_manager = AdminManager(base_dir=base_dir)&#10;            self.examen_workflow = ExamenWorkflowService()&#10;            # Override repos del workflow al mismo base_dir&#10;            self.examen_workflow.solicitud_repo.base_dir = base_dir&#10;            self.examen_workflow.resultado_repo.base_dir = base_dir&#10;        else:&#10;            self.paciente_manager = PacienteManager()&#10;            self.admin_manager = AdminManager()&#10;            self.examen_workflow = ExamenWorkflowService()  # Acceso a resultados workflow&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str,&#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            return self.paciente_manager.registrar_paciente(&#10;                documento, nombre_completo, contraseña, telefono, email, edad, sexo&#10;            )&#10;        except ValueError as e:&#10;            raise e&#10;        except Exception as e:&#10;            raise Exception(f&quot;Error al registrar paciente: {str(e)}&quot;)&#10;&#10;    def login_paciente(self, documento: str, contraseña: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente y genera un token de acceso.&#10;        &quot;&quot;&quot;&#10;        if self.paciente_manager.autenticar_paciente(documento, contraseña):&#10;            # Obtener datos del paciente sin la contraseña&#10;            datos_paciente = self.paciente_manager.obtener_datos_paciente(documento)&#10;            if datos_paciente:&#10;                # Crear token de acceso con los datos del paciente&#10;                token = crear_token_acceso({&#10;                    &quot;documento&quot;: documento,&#10;                    &quot;nombre_completo&quot;: datos_paciente[&quot;nombre_completo&quot;],&#10;                    &quot;tipo_usuario&quot;: &quot;paciente&quot;&#10;                })&#10;                &#10;                return {&#10;                    &quot;token&quot;: token,&#10;                    &quot;paciente&quot;: datos_paciente&#10;                }&#10;        &#10;        raise ValueError(&quot;Credenciales inválidas&quot;)&#10;&#10;    def verificar_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return self.paciente_manager.existe_paciente(documento)&#10;&#10;    def obtener_examenes_paciente(self, documento: str) -&gt; list:&#10;        &quot;&quot;&quot;&#10;        Obtiene todos los exámenes de un paciente.&#10;        &quot;&quot;&quot;&#10;        #legacy = self.admin_manager.listar_examenes_paciente(documento)&#10;        workflow = self.examen_workflow.listar_resultados_paciente(documento)&#10;        normalizados = []&#10;        # for ex in legacy:&#10;        #     normalizados.append({&#10;        #         &quot;codigo&quot;: ex.get(&quot;codigo_examen&quot;),&#10;        #         &quot;tipo_examen&quot;: ex.get(&quot;examen_solicitado&quot;),&#10;        #         &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;        #         &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;        #         &quot;documento_medico&quot;: (ex.get(&quot;medico&quot;) or {}).get(&quot;documento&quot;),&#10;        #         &quot;diagnostico&quot;: ex.get(&quot;diagnostico&quot;),&#10;        #         &quot;interpretacion&quot;: ex.get(&quot;diagnostico&quot;),  # legacy no distingue&#10;        #         &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;        #         &quot;estado&quot;: ex.get(&quot;estado&quot;),&#10;        #         &quot;estado_riesgo&quot;: None,&#10;        #         &quot;origen&quot;: &quot;legacy&quot;,&#10;        #         &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;        #     })&#10;        for ex in workflow:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;id&quot;),&#10;                &quot;tipo_examen&quot;: None,  # solicitud inicial guarda tipo en solicitud, no en resultado&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: ex.get(&quot;documento_medico&quot;),&#10;                &quot;diagnostico&quot;: None,&#10;                &quot;interpretacion&quot;: ex.get(&quot;interpretacion&quot;),&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: &quot;resultado&quot;,  # resultado consolidado&#10;                &quot;estado_riesgo&quot;: ex.get(&quot;estado_riesgo&quot;),&#10;                &quot;origen&quot;: &quot;workflow&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        return normalizados&#10;&#10;    def obtener_resultado_examen(self, codigo_examen: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene el resultado de un examen específico.&#10;        &quot;&quot;&quot;&#10;        # Intentar legacy&#10;        ex_legacy = self.admin_manager.obtener_resultado_examen(codigo_examen)&#10;        if ex_legacy:&#10;            return ex_legacy&#10;        # Buscar en resultados workflow (lista completa)&#10;        for r in self.examen_workflow.resultado_repo.list():&#10;            if r.get(&quot;id&quot;) == codigo_examen or r.get(&quot;solicitud_id&quot;) == codigo_examen:&#10;                return r&#10;        return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="pytest&#10;fastapi&gt;=0.68.0&#10;uvicorn&gt;=0.15.0&#10;pytest&gt;=6.2.4&#10;pydantic&gt;=1.8.2&#10;starlette&gt;=0.14.2&#10;filelock&#10;pyjwt&#10;python-dotenv" />
              <option name="updatedContent" value="pytest&#10;fastapi&gt;=0.68.0&#10;uvicorn&gt;=0.15.0&#10;pytest&gt;=6.2.4&#10;pydantic&gt;=1.8.2&#10;starlette&gt;=0.14.2&#10;filelock&#10;pyjwt&#10;python-dotenv" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/test_paciente_examenes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/test_paciente_examenes.py" />
              <option name="originalContent" value="import tempfile&#10;from app.services.paciente_service import PacienteService&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.managers.admin_manager import AdminManager&#10;from app.managers.paciente_manager import PacienteManager&#10;from app.config import BASE_DATA_DIR&#10;from pathlib import Path&#10;import os&#10;import shutil&#10;&#10;# Tests básicos de integración mínima para ver exámenes combinados&#10;&#10;def _setup_tmp_dir():&#10;    tmp = tempfile.mkdtemp()&#10;    return Path(tmp)&#10;&#10;def test_paciente_examenes_fusion_workflow_legacy(monkeypatch):&#10;    base = _setup_tmp_dir()&#10;    # Instancias aisladas utilizando base_dir común&#10;    paciente_manager = PacienteManager(base_dir=base)&#10;    admin_manager = AdminManager(base_dir=base)&#10;    workflow = ExamenWorkflowService()&#10;    # Reasignar repos al base_dir&#10;    workflow.solicitud_repo.file_path = base / 'examenes_solicitudes.json'&#10;    workflow.resultado_repo.file_path = base / 'examenes_resultados.json'&#10;    service = PacienteService(base_dir=base)&#10;&#10;    # Registrar paciente&#10;    documento = &quot;PX001&quot;&#10;    paciente_manager.registrar_paciente(documento, &quot;Paciente X&quot;, &quot;clave&quot;, &quot;3000000000&quot;, &quot;px@example.com&quot;, 40, &quot;Masculino&quot;)&#10;&#10;    # Crear solicitud workflow (simula cita cerrada)&#10;    solicitud = workflow.crear_solicitud(&quot;CITA123&quot;, documento, &quot;M001&quot;, &quot;Glucosa&quot;)&#10;    workflow.autorizar_solicitud(solicitud[&quot;id&quot;])&#10;    resultado = workflow.registrar_resultado(solicitud[&quot;id&quot;], {&quot;glucosa&quot;: 150}, &quot;Controlar dieta&quot;)&#10;&#10;    # Crear examen legacy&#10;    admin_manager.crear_resultado_examen(&quot;EXLEG001&quot;, {&#10;        &quot;documento_paciente&quot;: documento,&#10;        &quot;paciente&quot;: &quot;Paciente X&quot;,&#10;        &quot;codigo_cita&quot;: &quot;CITA999&quot;,&#10;        &quot;examen_solicitado&quot;: &quot;Hemograma&quot;,&#10;        &quot;medico&quot;: {&quot;documento&quot;: &quot;M001&quot;},&#10;        &quot;diagnostico&quot;: &quot;Anemia leve&quot;,&#10;        &quot;estado&quot;: &quot;pendiente&quot;&#10;    })&#10;&#10;    ex_list = service.obtener_examenes_paciente(documento)&#10;    codigos = {e[&quot;codigo&quot;] for e in ex_list}&#10;    assert &quot;EXLEG001&quot; in codigos&#10;    assert resultado[&quot;id&quot;] in codigos&#10;    # Verificar origenes&#10;    origenes = {e[&quot;origen&quot;] for e in ex_list}&#10;    assert &quot;legacy&quot; in origenes and &quot;workflow&quot; in origenes&#10;&#10;    # Ver resultado individual workflow&#10;    detalle = service.obtener_resultado_examen(resultado[&quot;id&quot;])&#10;    assert detalle[&quot;id&quot;] == resultado[&quot;id&quot;]&#10;&#10;    # Ver resultado individual legacy&#10;    detalle_leg = service.obtener_resultado_examen(&quot;EXLEG001&quot;)&#10;    assert detalle_leg[&quot;codigo_examen&quot;] == &quot;EXLEG001&quot;&#10;&#10;    shutil.rmtree(base)&#10;" />
              <option name="updatedContent" value="import tempfile&#10;from app.services.paciente_service import PacienteService&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.managers.admin_manager import AdminManager&#10;from app.managers.paciente_manager import PacienteManager&#10;from app.config import BASE_DATA_DIR&#10;from pathlib import Path&#10;import os&#10;import shutil&#10;&#10;# Tests básicos de integración mínima para ver exámenes combinados&#10;&#10;def _setup_tmp_dir():&#10;    tmp = tempfile.mkdtemp()&#10;    return Path(tmp)&#10;&#10;def test_paciente_examenes_fusion_workflow_legacy(monkeypatch):&#10;    base = _setup_tmp_dir()&#10;    # Instancias aisladas utilizando base_dir común&#10;    paciente_manager = PacienteManager(base_dir=base)&#10;    admin_manager = AdminManager(base_dir=base)&#10;    workflow = ExamenWorkflowService()&#10;    # Reasignar repos al base_dir&#10;    workflow.solicitud_repo.file_path = base / 'examenes_solicitudes.json'&#10;    workflow.resultado_repo.file_path = base / 'examenes_resultados.json'&#10;    service = PacienteService(base_dir=base)&#10;&#10;    # Registrar paciente&#10;    documento = &quot;PX001&quot;&#10;    paciente_manager.registrar_paciente(documento, &quot;Paciente X&quot;, &quot;clave&quot;, &quot;3000000000&quot;, &quot;px@example.com&quot;, 40, &quot;Masculino&quot;)&#10;&#10;    # Crear solicitud workflow (simula cita cerrada)&#10;    solicitud = workflow.crear_solicitud(&quot;CITA123&quot;, documento, &quot;M001&quot;, &quot;Glucosa&quot;)&#10;    workflow.autorizar_solicitud(solicitud[&quot;id&quot;])&#10;    resultado = workflow.registrar_resultado(solicitud[&quot;id&quot;], {&quot;glucosa&quot;: 150}, &quot;Controlar dieta&quot;)&#10;&#10;    # Crear examen legacy&#10;    admin_manager.crear_resultado_examen(&quot;EXLEG001&quot;, {&#10;        &quot;documento_paciente&quot;: documento,&#10;        &quot;paciente&quot;: &quot;Paciente X&quot;,&#10;        &quot;codigo_cita&quot;: &quot;CITA999&quot;,&#10;        &quot;examen_solicitado&quot;: &quot;Hemograma&quot;,&#10;        &quot;medico&quot;: {&quot;documento&quot;: &quot;M001&quot;},&#10;        &quot;diagnostico&quot;: &quot;Anemia leve&quot;,&#10;        &quot;estado&quot;: &quot;pendiente&quot;&#10;    })&#10;&#10;    ex_list = service.obtener_examenes_paciente(documento)&#10;    codigos = {e[&quot;codigo&quot;] for e in ex_list}&#10;    assert &quot;EXLEG001&quot; in codigos&#10;    assert resultado[&quot;id&quot;] in codigos&#10;    # Verificar origenes&#10;    origenes = {e[&quot;origen&quot;] for e in ex_list}&#10;    assert &quot;legacy&quot; in origenes and &quot;workflow&quot; in origenes&#10;&#10;    # Ver resultado individual workflow&#10;    detalle = service.obtener_resultado_examen(resultado[&quot;id&quot;])&#10;    assert detalle[&quot;id&quot;] == resultado[&quot;id&quot;]&#10;&#10;    # Ver resultado individual legacy&#10;    detalle_leg = service.obtener_resultado_examen(&quot;EXLEG001&quot;)&#10;    assert detalle_leg[&quot;codigo_examen&quot;] == &quot;EXLEG001&quot;&#10;&#10;    shutil.rmtree(base)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/services/citas_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/citas_service.py" />
              <option name="originalContent" value="from app.managers.cita_manager import CitaManager&#10;from app.metrics.metrics import inc_cita_agendada&#10;&#10;class CitasService:&#10;    def __init__(self):&#10;        self.citaManagerInstance = CitaManager()&#10;&#10;    def crear_cita_service(self,paciente,medico,fecha,documento, tipoCita, motivoPaciente):&#10;        cita = self.citaManagerInstance.agendar_cita(paciente, medico, fecha, documento, tipoCita, motivoPaciente)&#10;        if cita:&#10;            inc_cita_agendada()&#10;        return cita&#10;&#10;    def eliminar_cita_service(self,paciente,medico,fecha,documento):&#10;        return self.citaManagerInstance.eliminar_cita(paciente, medico, fecha, documento)&#10;&#10;    def  obtener_citas_paciente_service(self,documento):&#10;        return self.citaManagerInstance.obtener_citas_paciente(documento)" />
              <option name="updatedContent" value="from app.managers.cita_manager import CitaManager&#10;from app.metrics.metrics import inc_cita_agendada&#10;&#10;class CitasService:&#10;    def __init__(self):&#10;        self.citaManagerInstance = CitaManager()&#10;&#10;    def crear_cita_service(self,paciente,medico,fecha,documento, tipoCita, motivoPaciente):&#10;        cita = self.citaManagerInstance.agendar_cita(paciente, medico, fecha, documento, tipoCita, motivoPaciente)&#10;        if cita:&#10;            inc_cita_agendada()&#10;        return cita&#10;&#10;    def eliminar_cita_service(self,paciente,medico,fecha,documento):&#10;        return self.citaManagerInstance.eliminar_cita(paciente, medico, fecha, documento)&#10;&#10;    def  obtener_citas_paciente_service(self,documento):&#10;        return self.citaManagerInstance.obtener_citas_paciente(documento)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/examen_workflow_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/examen_workflow_service.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Servicio de workflow de Exámenes.&#10;Responsabilidad:&#10;- Crear solicitudes de examen ligadas a cita&#10;- Autorizar / rechazar (rol admin)&#10;- Registrar resultado (rol admin/lab) y evaluar riesgo&#10;Relaciones:&#10;- Usa repositorios de ExamenSolicitud y ExamenResultado&#10;- Interactúa potencialmente con AlertaService para generar alertas por resultado crítico&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;from typing import Dict, Any&#10;from uuid import uuid4&#10;from datetime import datetime, timezone&#10;from app.config import BASE_DATA_DIR&#10;from app.repositories.examen_repository import ExamenSolicitudRepository, ExamenResultadoRepository&#10;from app.models.examen import ExamenSolicitud, ExamenResultado&#10;from app.models.base import EstadoExamen&#10;from app.metrics.metrics import inc_examen_solicitado&#10;&#10;class ExamenWorkflowService:&#10;    # Leyenda: Orquesta el ciclo de vida de un examen.&#10;    # No implementa reglas complejas de alertas; delega a un servicio especializado.&#10;    # Agnóstico de la fuente de datos: repositorios pueden migrar a SQL sin cambiar este servicio.&#10;    def __init__(self):&#10;        self.solicitud_repo = ExamenSolicitudRepository(BASE_DATA_DIR)&#10;        self.resultado_repo = ExamenResultadoRepository(BASE_DATA_DIR)&#10;&#10;    def crear_solicitud(self, codigo_cita: str, documento_paciente: str, documento_medico: str, tipo_examen: str) -&gt; Dict[str, Any]:&#10;        solicitud = ExamenSolicitud(&#10;            id=str(uuid4()),&#10;            codigo_cita=codigo_cita,&#10;            documento_paciente=documento_paciente,&#10;            documento_medico=documento_medico,&#10;            tipo_examen=tipo_examen&#10;        )&#10;        self.solicitud_repo.insert(solicitud.model_dump())&#10;        inc_examen_solicitado()&#10;        return solicitud.model_dump()&#10;&#10;    def autorizar_solicitud(self, solicitud_id: str) -&gt; Dict[str, Any]:&#10;        updated = self.solicitud_repo.update(solicitud_id, lambda s: self._transicion_autorizar(s))&#10;        if not updated:&#10;            raise ValueError(&quot;Solicitud no encontrada&quot;)&#10;        return updated&#10;&#10;    def _transicion_autorizar(self, solicitud: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        if solicitud.get(&quot;estado&quot;) != EstadoExamen.solicitado:&#10;            raise ValueError(&quot;Estado inválido para autorización&quot;)&#10;        solicitud[&quot;estado&quot;] = EstadoExamen.autorizado&#10;        solicitud[&quot;fecha_autorizacion&quot;] = datetime.now(timezone.utc).isoformat()&#10;        return solicitud&#10;&#10;    def registrar_resultado(self, solicitud_id: str, valores: Dict[str, float], interpretacion: str | None = None) -&gt; Dict[str, Any]:&#10;        solicitud = self.solicitud_repo.get(solicitud_id)&#10;        if not solicitud:&#10;            raise ValueError(&quot;Solicitud no encontrada&quot;)&#10;        if solicitud.get(&quot;estado&quot;) not in [EstadoExamen.autorizado, EstadoExamen.procesando]:&#10;            raise ValueError(&quot;No se puede registrar resultado en el estado actual&quot;)&#10;        resultado = ExamenResultado(&#10;            id=str(uuid4()),&#10;            solicitud_id=solicitud_id,&#10;            codigo_cita=solicitud[&quot;codigo_cita&quot;],&#10;            documento_paciente=solicitud[&quot;documento_paciente&quot;],&#10;            documento_medico=solicitud[&quot;documento_medico&quot;],&#10;            valores=valores,&#10;            interpretacion=interpretacion,&#10;            estado_riesgo=self._evaluar_riesgo(valores)&#10;        )&#10;        self.resultado_repo.insert(resultado.model_dump())&#10;        self.solicitud_repo.update(solicitud_id, lambda s: self._transicion_resultado(s))&#10;        return resultado.model_dump()&#10;&#10;    def _transicion_resultado(self, solicitud: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        solicitud[&quot;estado&quot;] = EstadoExamen.resultado&#10;        solicitud[&quot;fecha_resultado&quot;] = datetime.now(timezone.utc).isoformat()&#10;        return solicitud&#10;&#10;    def _evaluar_riesgo(self, valores: Dict[str, float]) -&gt; str:&#10;        niveles = [v for v in valores.values()]&#10;        if any(v &gt; 180 for v in niveles):&#10;            return &quot;critico&quot;&#10;        if any(v &gt; 140 for v in niveles):&#10;            return &quot;alerta&quot;&#10;        return &quot;normal&quot;&#10;&#10;    def listar_resultados_paciente(self, documento_paciente: str) -&gt; list:&#10;        return self.resultado_repo.listar_por_paciente(documento_paciente)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;Servicio de workflow de Exámenes.&#10;Responsabilidad:&#10;- Crear solicitudes de examen ligadas a cita&#10;- Autorizar / rechazar (rol admin)&#10;- Registrar resultado (rol admin/lab) y evaluar riesgo&#10;Relaciones:&#10;- Usa repositorios de ExamenSolicitud y ExamenResultado&#10;- Interactúa potencialmente con AlertaService para generar alertas por resultado crítico&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;from typing import Dict, Any&#10;from uuid import uuid4&#10;from datetime import datetime, timezone&#10;from app.config import BASE_DATA_DIR&#10;from app.repositories.examen_repository import ExamenSolicitudRepository, ExamenResultadoRepository&#10;from app.models.examen import ExamenSolicitud, ExamenResultado&#10;from app.models.base import EstadoExamen&#10;from app.metrics.metrics import inc_examen_solicitado&#10;&#10;class ExamenWorkflowService:&#10;    # Leyenda: Orquesta el ciclo de vida de un examen.&#10;    # No implementa reglas complejas de alertas; delega a un servicio especializado.&#10;    # Agnóstico de la fuente de datos: repositorios pueden migrar a SQL sin cambiar este servicio.&#10;    def __init__(self):&#10;        self.solicitud_repo = ExamenSolicitudRepository(BASE_DATA_DIR)&#10;        self.resultado_repo = ExamenResultadoRepository(BASE_DATA_DIR)&#10;&#10;    def crear_solicitud(self, codigo_cita: str, documento_paciente: str, documento_medico: str, tipo_examen: str) -&gt; Dict[str, Any]:&#10;        solicitud = ExamenSolicitud(&#10;            id=str(uuid4()),&#10;            codigo_cita=codigo_cita,&#10;            documento_paciente=documento_paciente,&#10;            documento_medico=documento_medico,&#10;            tipo_examen=tipo_examen&#10;        )&#10;        self.solicitud_repo.insert(solicitud.model_dump())&#10;        inc_examen_solicitado()&#10;        return solicitud.model_dump()&#10;&#10;    def autorizar_solicitud(self, solicitud_id: str) -&gt; Dict[str, Any]:&#10;        updated = self.solicitud_repo.update(solicitud_id, lambda s: self._transicion_autorizar(s))&#10;        if not updated:&#10;            raise ValueError(&quot;Solicitud no encontrada&quot;)&#10;        return updated&#10;&#10;    def _transicion_autorizar(self, solicitud: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        if solicitud.get(&quot;estado&quot;) != EstadoExamen.solicitado:&#10;            raise ValueError(&quot;Estado inválido para autorización&quot;)&#10;        solicitud[&quot;estado&quot;] = EstadoExamen.autorizado&#10;        solicitud[&quot;fecha_autorizacion&quot;] = datetime.now(timezone.utc).isoformat()&#10;        return solicitud&#10;&#10;    def registrar_resultado(self, solicitud_id: str, valores: Dict[str, float], interpretacion: str | None = None) -&gt; Dict[str, Any]:&#10;        solicitud = self.solicitud_repo.get(solicitud_id)&#10;        if not solicitud:&#10;            raise ValueError(&quot;Solicitud no encontrada&quot;)&#10;        if solicitud.get(&quot;estado&quot;) not in [EstadoExamen.autorizado, EstadoExamen.procesando]:&#10;            raise ValueError(&quot;No se puede registrar resultado en el estado actual&quot;)&#10;        resultado = ExamenResultado(&#10;            id=str(uuid4()),&#10;            solicitud_id=solicitud_id,&#10;            codigo_cita=solicitud[&quot;codigo_cita&quot;],&#10;            documento_paciente=solicitud[&quot;documento_paciente&quot;],&#10;            documento_medico=solicitud[&quot;documento_medico&quot;],&#10;            valores=valores,&#10;            interpretacion=interpretacion,&#10;            estado_riesgo=self._evaluar_riesgo(valores)&#10;        )&#10;        self.resultado_repo.insert(resultado.model_dump())&#10;        self.solicitud_repo.update(solicitud_id, lambda s: self._transicion_resultado(s))&#10;        return resultado.model_dump()&#10;&#10;    def _transicion_resultado(self, solicitud: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        solicitud[&quot;estado&quot;] = EstadoExamen.resultado&#10;        solicitud[&quot;fecha_resultado&quot;] = datetime.now(timezone.utc).isoformat()&#10;        return solicitud&#10;&#10;    def _evaluar_riesgo(self, valores: Dict[str, float]) -&gt; str:&#10;        niveles = [v for v in valores.values()]&#10;        if any(v &gt; 180 for v in niveles):&#10;            return &quot;critico&quot;&#10;        if any(v &gt; 140 for v in niveles):&#10;            return &quot;alerta&quot;&#10;        return &quot;normal&quot;&#10;&#10;    def listar_resultados_paciente(self, documento_paciente: str) -&gt; list:&#10;        return self.resultado_repo.listar_por_paciente(documento_paciente)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/paciente_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/paciente_service.py" />
              <option name="originalContent" value="from app.managers.paciente_manager import PacienteManager&#10;from app.config import crear_token_acceso&#10;from app.managers.admin_manager import AdminManager&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.metrics.metrics import inc_paciente_registrado, inc_paciente_login&#10;from pathlib import Path&#10;&#10;&#10;class PacienteService:&#10;    # Leyenda: Servicio de pacientes.&#10;    # Responsabilidades: registro, login, lectura de exámenes (legacy), verificación existencia.&#10;    # Próxima migración: usar repositorios para separar persistencia; unificar acceso a exámenes vía workflow.&#10;    def __init__(self, base_dir=None):&#10;        if base_dir is not None:&#10;            from app.config import BASE_DATA_DIR as GLOBAL_BASE&#10;            # Reasignar BASE_DATA_DIR dinámicamente para este servicio no es trivial; usamos base_dir explícito.&#10;            self.paciente_manager = PacienteManager(base_dir=base_dir)&#10;            self.admin_manager = AdminManager(base_dir=base_dir)&#10;            self.examen_workflow = ExamenWorkflowService()&#10;            # Reasignar repos del workflow al mismo base_dir (ajuste: usar file_path explícito)&#10;            base_path = Path(base_dir)&#10;            self.examen_workflow.solicitud_repo.file_path = base_path / 'examenes_solicitudes.json'&#10;            self.examen_workflow.resultado_repo.file_path = base_path / 'examenes_resultados.json'&#10;        else:&#10;            self.paciente_manager = PacienteManager()&#10;            self.admin_manager = AdminManager()&#10;            self.examen_workflow = ExamenWorkflowService()  # Acceso a resultados workflow&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str,&#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            registro = self.paciente_manager.registrar_paciente(&#10;                documento, nombre_completo, contraseña, telefono, email, edad, sexo&#10;            )&#10;            if registro:&#10;                inc_paciente_registrado()&#10;            return registro&#10;        except ValueError as e:&#10;            raise e&#10;        except Exception as e:&#10;            raise Exception(f&quot;Error al registrar paciente: {str(e)}&quot;)&#10;&#10;    def login_paciente(self, documento: str, contraseña: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente y genera un token de acceso.&#10;        &quot;&quot;&quot;&#10;        if self.paciente_manager.autenticar_paciente(documento, contraseña):&#10;            # Obtener datos del paciente sin la contraseña&#10;            datos_paciente = self.paciente_manager.obtener_datos_paciente(documento)&#10;            if datos_paciente:&#10;                # Crear token de acceso con los datos del paciente&#10;                token = crear_token_acceso({&#10;                    &quot;documento&quot;: documento,&#10;                    &quot;nombre_completo&quot;: datos_paciente[&quot;nombre_completo&quot;],&#10;                    &quot;tipo_usuario&quot;: &quot;paciente&quot;&#10;                })&#10;                &#10;                inc_paciente_login()&#10;                return {&#10;                    &quot;token&quot;: token,&#10;                    &quot;paciente&quot;: datos_paciente&#10;                }&#10;        &#10;        raise ValueError(&quot;Credenciales inválidas&quot;)&#10;&#10;    def verificar_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return self.paciente_manager.existe_paciente(documento)&#10;&#10;    def obtener_examenes_paciente(self, documento: str) -&gt; list:&#10;        &quot;&quot;&quot;&#10;        Obtiene todos los exámenes de un paciente.&#10;        Incluye legacy + workflow normalizados.&#10;        &quot;&quot;&quot;&#10;        legacy = self.admin_manager.listar_examenes_paciente(documento)&#10;        workflow = self.examen_workflow.listar_resultados_paciente(documento)&#10;        normalizados = []&#10;        for ex in legacy:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;codigo_examen&quot;),&#10;                &quot;tipo_examen&quot;: ex.get(&quot;examen_solicitado&quot;),&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: (ex.get(&quot;medico&quot;) or {}).get(&quot;documento&quot;),&#10;                &quot;diagnostico&quot;: ex.get(&quot;diagnostico&quot;),&#10;                &quot;interpretacion&quot;: ex.get(&quot;diagnostico&quot;),  # legacy no distingue&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: ex.get(&quot;estado&quot;),&#10;                &quot;estado_riesgo&quot;: None,&#10;                &quot;origen&quot;: &quot;legacy&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        for ex in workflow:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;id&quot;),&#10;                &quot;tipo_examen&quot;: ex.get(&quot;tipo_examen&quot;),&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: ex.get(&quot;documento_medico&quot;),&#10;                &quot;diagnostico&quot;: None,&#10;                &quot;interpretacion&quot;: ex.get(&quot;interpretacion&quot;),&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: &quot;resultado&quot;,&#10;                &quot;estado_riesgo&quot;: ex.get(&quot;estado_riesgo&quot;),&#10;                &quot;origen&quot;: &quot;workflow&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        return normalizados&#10;&#10;    def obtener_resultado_examen(self, codigo_examen: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene el resultado de un examen específico.&#10;        &quot;&quot;&quot;&#10;        # Intentar legacy&#10;        ex_legacy = self.admin_manager.obtener_resultado_examen(codigo_examen)&#10;        if ex_legacy:&#10;            return ex_legacy&#10;        # Buscar en resultados workflow (lista completa)&#10;        for r in self.examen_workflow.resultado_repo.list():&#10;            if r.get(&quot;id&quot;) == codigo_examen or r.get(&quot;solicitud_id&quot;) == codigo_examen:&#10;                return r&#10;        return None&#10;" />
              <option name="updatedContent" value="from app.managers.paciente_manager import PacienteManager&#10;from app.config import crear_token_acceso&#10;from app.managers.admin_manager import AdminManager&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.metrics.metrics import inc_paciente_registrado, inc_paciente_login&#10;from pathlib import Path&#10;&#10;&#10;class PacienteService:&#10;    # Leyenda: Servicio de pacientes.&#10;    # Responsabilidades: registro, login, lectura de exámenes (legacy), verificación existencia.&#10;    # Próxima migración: usar repositorios para separar persistencia; unificar acceso a exámenes vía workflow.&#10;    def __init__(self, base_dir=None):&#10;        if base_dir is not None:&#10;            from app.config import BASE_DATA_DIR as GLOBAL_BASE&#10;            # Reasignar BASE_DATA_DIR dinámicamente para este servicio no es trivial; usamos base_dir explícito.&#10;            self.paciente_manager = PacienteManager(base_dir=base_dir)&#10;            self.admin_manager = AdminManager(base_dir=base_dir)&#10;            self.examen_workflow = ExamenWorkflowService()&#10;            # Reasignar repos del workflow al mismo base_dir (ajuste: usar file_path explícito)&#10;            base_path = Path(base_dir)&#10;            self.examen_workflow.solicitud_repo.file_path = base_path / 'examenes_solicitudes.json'&#10;            self.examen_workflow.resultado_repo.file_path = base_path / 'examenes_resultados.json'&#10;        else:&#10;            self.paciente_manager = PacienteManager()&#10;            self.admin_manager = AdminManager()&#10;            self.examen_workflow = ExamenWorkflowService()  # Acceso a resultados workflow&#10;&#10;    def registrar_paciente(self, documento: str, nombre_completo: str, contraseña: str,&#10;                          telefono: str, email: str, edad: int, sexo: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Registra un nuevo paciente en el sistema.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            registro = self.paciente_manager.registrar_paciente(&#10;                documento, nombre_completo, contraseña, telefono, email, edad, sexo&#10;            )&#10;            if registro:&#10;                inc_paciente_registrado()&#10;            return registro&#10;        except ValueError as e:&#10;            raise e&#10;        except Exception as e:&#10;            raise Exception(f&quot;Error al registrar paciente: {str(e)}&quot;)&#10;&#10;    def login_paciente(self, documento: str, contraseña: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Autentica a un paciente y genera un token de acceso.&#10;        &quot;&quot;&quot;&#10;        if self.paciente_manager.autenticar_paciente(documento, contraseña):&#10;            # Obtener datos del paciente sin la contraseña&#10;            datos_paciente = self.paciente_manager.obtener_datos_paciente(documento)&#10;            if datos_paciente:&#10;                # Crear token de acceso con los datos del paciente&#10;                token = crear_token_acceso({&#10;                    &quot;documento&quot;: documento,&#10;                    &quot;nombre_completo&quot;: datos_paciente[&quot;nombre_completo&quot;],&#10;                    &quot;tipo_usuario&quot;: &quot;paciente&quot;&#10;                })&#10;                &#10;                inc_paciente_login()&#10;                return {&#10;                    &quot;token&quot;: token,&#10;                    &quot;paciente&quot;: datos_paciente&#10;                }&#10;        &#10;        raise ValueError(&quot;Credenciales inválidas&quot;)&#10;&#10;    def verificar_paciente(self, documento: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Verifica si un paciente está registrado en el sistema.&#10;        &quot;&quot;&quot;&#10;        return self.paciente_manager.existe_paciente(documento)&#10;&#10;    def obtener_examenes_paciente(self, documento: str) -&gt; list:&#10;        &quot;&quot;&quot;&#10;        Obtiene todos los exámenes de un paciente.&#10;        Incluye legacy + workflow normalizados.&#10;        &quot;&quot;&quot;&#10;        legacy = self.admin_manager.listar_examenes_paciente(documento)&#10;        workflow = self.examen_workflow.listar_resultados_paciente(documento)&#10;        normalizados = []&#10;        for ex in legacy:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;codigo_examen&quot;),&#10;                &quot;tipo_examen&quot;: ex.get(&quot;examen_solicitado&quot;),&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: (ex.get(&quot;medico&quot;) or {}).get(&quot;documento&quot;),&#10;                &quot;diagnostico&quot;: ex.get(&quot;diagnostico&quot;),&#10;                &quot;interpretacion&quot;: ex.get(&quot;diagnostico&quot;),  # legacy no distingue&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: ex.get(&quot;estado&quot;),&#10;                &quot;estado_riesgo&quot;: None,&#10;                &quot;origen&quot;: &quot;legacy&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        for ex in workflow:&#10;            normalizados.append({&#10;                &quot;codigo&quot;: ex.get(&quot;id&quot;),&#10;                &quot;tipo_examen&quot;: ex.get(&quot;tipo_examen&quot;),&#10;                &quot;codigo_cita&quot;: ex.get(&quot;codigo_cita&quot;),&#10;                &quot;documento_paciente&quot;: ex.get(&quot;documento_paciente&quot;),&#10;                &quot;documento_medico&quot;: ex.get(&quot;documento_medico&quot;),&#10;                &quot;diagnostico&quot;: None,&#10;                &quot;interpretacion&quot;: ex.get(&quot;interpretacion&quot;),&#10;                &quot;valores&quot;: ex.get(&quot;valores&quot;),&#10;                &quot;estado&quot;: &quot;resultado&quot;,&#10;                &quot;estado_riesgo&quot;: ex.get(&quot;estado_riesgo&quot;),&#10;                &quot;origen&quot;: &quot;workflow&quot;,&#10;                &quot;fecha_registro&quot;: ex.get(&quot;fecha_registro&quot;)&#10;            })&#10;        return normalizados&#10;&#10;    def obtener_resultado_examen(self, codigo_examen: str) -&gt; dict:&#10;        &quot;&quot;&quot;&#10;        Obtiene el resultado de un examen específico.&#10;        &quot;&quot;&quot;&#10;        # Intentar legacy&#10;        ex_legacy = self.admin_manager.obtener_resultado_examen(codigo_examen)&#10;        if ex_legacy:&#10;            return ex_legacy&#10;        # Buscar en resultados workflow (lista completa)&#10;        for r in self.examen_workflow.resultado_repo.list():&#10;            if r.get(&quot;id&quot;) == codigo_examen or r.get(&quot;solicitud_id&quot;) == codigo_examen:&#10;                return r&#10;        return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="pytest&#10;fastapi&gt;=0.68.0&#10;uvicorn&gt;=0.15.0&#10;pytest&gt;=6.2.4&#10;pydantic&gt;=1.8.2&#10;starlette&gt;=0.14.2&#10;filelock&#10;pyjwt&#10;python-dotenv&#10;prometheus_client==0.20.0&#10;httpx" />
              <option name="updatedContent" value="pytest&#10;fastapi&gt;=0.68.0&#10;uvicorn&gt;=0.15.0&#10;pytest&gt;=6.2.4&#10;pydantic&gt;=1.8.2&#10;starlette&gt;=0.14.2&#10;filelock&#10;pyjwt&#10;python-dotenv&#10;prometheus_client==0.20.0&#10;httpx" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/test_paciente_examenes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/test_paciente_examenes.py" />
              <option name="originalContent" value="import tempfile&#10;from app.services.paciente_service import PacienteService&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.managers.admin_manager import AdminManager&#10;from app.managers.paciente_manager import PacienteManager&#10;from app.config import BASE_DATA_DIR&#10;from pathlib import Path&#10;import os&#10;import shutil&#10;&#10;# Tests básicos de integración mínima para ver exámenes combinados&#10;&#10;def _setup_tmp_dir():&#10;    tmp = tempfile.mkdtemp()&#10;    return Path(tmp)&#10;&#10;def test_paciente_examenes_fusion_workflow_legacy(monkeypatch):&#10;    base = _setup_tmp_dir()&#10;    # Instancias aisladas utilizando base_dir común&#10;    paciente_manager = PacienteManager(base_dir=base)&#10;    admin_manager = AdminManager(base_dir=base)&#10;    workflow = ExamenWorkflowService()&#10;    # Reasignar repos al base_dir&#10;    workflow.solicitud_repo.file_path = base / 'examenes_solicitudes.json'&#10;    workflow.resultado_repo.file_path = base / 'examenes_resultados.json'&#10;    service = PacienteService(base_dir=base)&#10;&#10;    # Registrar paciente&#10;    documento = &quot;PX001&quot;&#10;    paciente_manager.registrar_paciente(documento, &quot;Paciente X&quot;, &quot;clave&quot;, &quot;3000000000&quot;, &quot;px@example.com&quot;, 40, &quot;Masculino&quot;)&#10;&#10;    # Crear solicitud workflow (simula cita cerrada)&#10;    solicitud = workflow.crear_solicitud(&quot;CITA123&quot;, documento, &quot;M001&quot;, &quot;Glucosa&quot;)&#10;    workflow.autorizar_solicitud(solicitud[&quot;id&quot;])&#10;    resultado = workflow.registrar_resultado(solicitud[&quot;id&quot;], {&quot;glucosa&quot;: 150}, &quot;Controlar dieta&quot;)&#10;&#10;    # Crear examen legacy&#10;    admin_manager.crear_resultado_examen(&quot;EXLEG001&quot;, {&#10;        &quot;documento_paciente&quot;: documento,&#10;        &quot;paciente&quot;: &quot;Paciente X&quot;,&#10;        &quot;codigo_cita&quot;: &quot;CITA999&quot;,&#10;        &quot;examen_solicitado&quot;: &quot;Hemograma&quot;,&#10;        &quot;medico&quot;: {&quot;documento&quot;: &quot;M001&quot;},&#10;        &quot;diagnostico&quot;: &quot;Anemia leve&quot;,&#10;        &quot;estado&quot;: &quot;pendiente&quot;&#10;    })&#10;&#10;    ex_list = service.obtener_examenes_paciente(documento)&#10;    codigos = {e[&quot;codigo&quot;] for e in ex_list}&#10;    assert &quot;EXLEG001&quot; in codigos&#10;    assert resultado[&quot;id&quot;] in codigos&#10;    # Verificar origenes&#10;    origenes = {e[&quot;origen&quot;] for e in ex_list}&#10;    assert &quot;legacy&quot; in origenes and &quot;workflow&quot; in origenes&#10;&#10;    # Ver resultado individual workflow&#10;    detalle = service.obtener_resultado_examen(resultado[&quot;id&quot;])&#10;    assert detalle[&quot;id&quot;] == resultado[&quot;id&quot;]&#10;&#10;    # Ver resultado individual legacy&#10;    detalle_leg = service.obtener_resultado_examen(&quot;EXLEG001&quot;)&#10;    assert detalle_leg[&quot;codigo_examen&quot;] == &quot;EXLEG001&quot;&#10;&#10;    shutil.rmtree(base)&#10;" />
              <option name="updatedContent" value="import tempfile&#10;from app.services.paciente_service import PacienteService&#10;from app.services.examen_workflow_service import ExamenWorkflowService&#10;from app.managers.admin_manager import AdminManager&#10;from app.managers.paciente_manager import PacienteManager&#10;from app.config import BASE_DATA_DIR&#10;from pathlib import Path&#10;import os&#10;import shutil&#10;&#10;# Tests básicos de integración mínima para ver exámenes combinados&#10;&#10;def _setup_tmp_dir():&#10;    tmp = tempfile.mkdtemp()&#10;    return Path(tmp)&#10;&#10;def test_paciente_examenes_fusion_workflow_legacy(monkeypatch):&#10;    base = _setup_tmp_dir()&#10;    # Instancias aisladas utilizando base_dir común&#10;    paciente_manager = PacienteManager(base_dir=base)&#10;    admin_manager = AdminManager(base_dir=base)&#10;    workflow = ExamenWorkflowService()&#10;    # Reasignar repos al base_dir&#10;    workflow.solicitud_repo.file_path = base / 'examenes_solicitudes.json'&#10;    workflow.resultado_repo.file_path = base / 'examenes_resultados.json'&#10;    service = PacienteService(base_dir=base)&#10;&#10;    # Registrar paciente&#10;    documento = &quot;PX001&quot;&#10;    paciente_manager.registrar_paciente(documento, &quot;Paciente X&quot;, &quot;clave&quot;, &quot;3000000000&quot;, &quot;px@example.com&quot;, 40, &quot;Masculino&quot;)&#10;&#10;    # Crear solicitud workflow (simula cita cerrada)&#10;    solicitud = workflow.crear_solicitud(&quot;CITA123&quot;, documento, &quot;M001&quot;, &quot;Glucosa&quot;)&#10;    workflow.autorizar_solicitud(solicitud[&quot;id&quot;])&#10;    resultado = workflow.registrar_resultado(solicitud[&quot;id&quot;], {&quot;glucosa&quot;: 150}, &quot;Controlar dieta&quot;)&#10;&#10;    # Crear examen legacy&#10;    admin_manager.crear_resultado_examen(&quot;EXLEG001&quot;, {&#10;        &quot;documento_paciente&quot;: documento,&#10;        &quot;paciente&quot;: &quot;Paciente X&quot;,&#10;        &quot;codigo_cita&quot;: &quot;CITA999&quot;,&#10;        &quot;examen_solicitado&quot;: &quot;Hemograma&quot;,&#10;        &quot;medico&quot;: {&quot;documento&quot;: &quot;M001&quot;},&#10;        &quot;diagnostico&quot;: &quot;Anemia leve&quot;,&#10;        &quot;estado&quot;: &quot;pendiente&quot;&#10;    })&#10;&#10;    ex_list = service.obtener_examenes_paciente(documento)&#10;    codigos = {e[&quot;codigo&quot;] for e in ex_list}&#10;    assert &quot;EXLEG001&quot; in codigos&#10;    assert resultado[&quot;id&quot;] in codigos&#10;    # Verificar origenes&#10;    origenes = {e[&quot;origen&quot;] for e in ex_list}&#10;    assert &quot;legacy&quot; in origenes and &quot;workflow&quot; in origenes&#10;&#10;    # Ver resultado individual workflow&#10;    detalle = service.obtener_resultado_examen(resultado[&quot;id&quot;])&#10;    assert detalle[&quot;id&quot;] == resultado[&quot;id&quot;]&#10;&#10;    # Ver resultado individual legacy&#10;    detalle_leg = service.obtener_resultado_examen(&quot;EXLEG001&quot;)&#10;    assert detalle_leg[&quot;codigo_examen&quot;] == &quot;EXLEG001&quot;&#10;&#10;    shutil.rmtree(base)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>